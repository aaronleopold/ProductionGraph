#![feature(prelude_import)]
#[prelude_import]
use std::prelude::v1::*;
#[macro_use]
extern crate std;
use pyo3::prelude::*;
use pyo3::wrap_pyfunction;
fn sum_vec(a: Vec<i32>) -> i32 {
    a.iter().sum()
}
fn __pyo3_get_function_sum_vec(py: pyo3::Python) -> pyo3::PyObject {
    unsafe extern "C" fn __wrap(
        _slf: *mut pyo3::ffi::PyObject,
        _args: *mut pyo3::ffi::PyObject,
        _kwargs: *mut pyo3::ffi::PyObject,
    ) -> *mut pyo3::ffi::PyObject {
        const _LOCATION: &'static str = "sum_vec()";
        {
            {
                let pool = ::pyo3::GILPool::new();
                let unwind_safe_py = std::panic::AssertUnwindSafe(pool.python());
                let result = match std::panic::catch_unwind(move || -> ::pyo3::PyResult<_> {
                    let _py = *unwind_safe_py;
                    ::pyo3::callback::convert(_py, {
                        let _args = _py.from_borrowed_ptr::<pyo3::types::PyTuple>(_args);
                        let _kwargs: Option<&pyo3::types::PyDict> =
                            _py.from_borrowed_ptr_or_opt(_kwargs);
                        {
                            const PARAMS: &'static [pyo3::derive_utils::ParamDescription] =
                                &[pyo3::derive_utils::ParamDescription {
                                    name: "a",
                                    is_optional: false,
                                    kw_only: false,
                                }];
                            let mut output = [None; 1usize];
                            let mut _args = _args;
                            let mut _kwargs = _kwargs;
                            let (_args, _kwargs) = pyo3::derive_utils::parse_fn_args(
                                Some(_LOCATION),
                                PARAMS,
                                _args,
                                _kwargs,
                                false,
                                false,
                                &mut output,
                            )?;
                            let arg0 = output[0usize].unwrap().extract()?;
                            sum_vec(arg0)
                        }
                    })
                }) {
                    Ok(result) => result,
                    Err(e) => {
                        if let Some(string) = e.downcast_ref::<String>() {
                            Err(::pyo3::panic::PanicException::py_err((string.clone(),)))
                        } else if let Some(s) = e.downcast_ref::<&str>() {
                            Err(::pyo3::panic::PanicException::py_err((s.to_string(),)))
                        } else {
                            Err(::pyo3::panic::PanicException::py_err((
                                "panic from Rust code",
                            )))
                        }
                    }
                };
                result.unwrap_or_else(|e| {
                    e.restore(pool.python());
                    ::pyo3::callback::callback_error()
                })
            }
        }
    }
    let _def = pyo3::class::PyMethodDef {
        ml_name: "sum_vec",
        ml_meth: pyo3::class::PyMethodType::PyCFunctionWithKeywords(__wrap),
        ml_flags: pyo3::ffi::METH_VARARGS | pyo3::ffi::METH_KEYWORDS,
        ml_doc: "\u{0}",
    };
    let function = unsafe {
        pyo3::PyObject::from_owned_ptr_or_panic(
            py,
            pyo3::ffi::PyCFunction_New(
                Box::into_raw(Box::new(_def.as_method_def())),
                ::std::ptr::null_mut(),
            ),
        )
    };
    function
}
fn arr_sum(py: Python, m: &PyModule) -> PyResult<()> {
    m.add_wrapped({
        &{
            #[allow(dead_code)]
            enum ProcMacroHack {
                Value = ("[< __pyo3_get_function_ sum_vec >]", 0).1,
            }
            {
                __pyo3_get_function_sum_vec
            }
        }
    })?;
    Ok(())
}
#[no_mangle]
#[allow(non_snake_case)]
#[doc = r" This autogenerated function is called by the python interpreter when importing"]
#[doc = r" the module."]
pub unsafe extern "C" fn PyInit_arr_sum() -> *mut pyo3::ffi::PyObject {
    use pyo3::derive_utils::ModuleDef;
    const NAME: &'static str = "arr_sum\u{0}";
    static MODULE_DEF: ModuleDef = unsafe { ModuleDef::new(NAME) };
    match MODULE_DEF.make_module("", arr_sum) {
        Ok(m) => m,
        Err(e) => e.restore_and_null(unsafe { pyo3::Python::assume_gil_acquired() }),
    }
}
